#ifndef _BOARD_2_PLUS_
#define _BOARD_2_PLUS_
 
#include "board_2.hxx"
#include "board_2_plus_help_classes.hxx"
#include "static_exchange_evaluation.hxx"

#include "move_set.hxx"
#include "my_vector.hxx"

class Board2plus : public Board2 {
public:
  // The constructor will NOT initialize to standard opening.
  Board2plus();
  ~Board2plus() { 
    if (PRINT_CONSTRUCTOR_DESTRUCTOR_CALLS)
      cerr << "Board2plus destructor called.\n";
  }

  Move sanToMove(string san);
  string moveToSAN(Move move);

  // this routine is faster than its equivalent in board_2
  int calc_game_status_ignore_50_move_rule_and_move_repetition();

  // Obtain the list of legal moves. CONTAINER must support add(...)
  template <class CONTAINER> void get_move_list(CONTAINER &moves);
  // same, but ignore moves from move_set. CONTAINER must support add(...)
  template <class CONTAINER> void get_move_list(CONTAINER &moves, MoveSet &move_set);

  // find_legal_move checks whether move.from and move.to matches a legal move.
  // In case of a match move.special_move and move.blah is set
  // (pawn promotion: default is queen). Is fast
  bool find_legal_move(Move& move);

  // set_board, loadFEN is remapping the piece numbers
  bool loadFEN(string FEN);

  static bool clr_board2plus(Board *board, ostream &os, vector<string> &p);

  bool king_capture_possible() {
    // king_capture_possible iff this player has control over enemy kings position
    return see.has_control(player, king_pos[player^1]);
  }

  // sanity_check checks whether the moves generated by board_2_plus
  // in the current position correspond to those generated by board_2
  bool sanity_check_moves(ostream &os);

  // static exchange evaluation stuff
  SEE see;
  void test_see();
  void init_see_list(MyVector<pair<Position, char> > &see_list, bool player,
		     int &num_protect, int &num_attack);
protected:
  // remap_piece_numbers are called after loadFEN and set_board.
  // 
  void remap_piece_numbers();
 
  void remove_piece(Position pos);
  void insert_piece(Position pos, Piece piece);
  void move_piece(Position from, Position to);

  virtual void reset_all();

  virtual bool internal_set_board();

  PieceNumber piece_number;
  MoveToIndex move_to_index;
  PieceMoves piece_moves;
  SquareMoveList square_move_list;
  MoveList move_list;

  // Functions to update the stuff above correctly
  bool remove_move(Move move);
  void add_move(Move move);
  void remove_blocked_moves(Position pos);
  void add_blocked_moves(Position pos);
  void remove_moves_by_piece_on_pos(Position pos);
  void add_moves_by_piece_on_pos(Position pos);

  //void initialize_move_list();

  // The move must be a semi legal move
  // transposition_table_legal_move:
  // if this function returns true, and hash_value_after_move(move)
  // is found in transposition table, then the move is legal
  bool legal_move(Move& move);


  // All moves stored by move_list must have move.blah set correctly
  void define_move_type(Move& move);

private:
  friend class SEE;

  // Private to prevent copying:
  Board2plus(const Board2plus&);
  Board2plus& operator=(const Board2plus&);
};



template <class CONTAINER>
void Board2plus::get_move_list(CONTAINER &moves) {
  //moves.clear();
  move_list.init_iterator(player);
  while (move_list.iterate()) {
    Move move = move_list.deref_iterator();
    // cerr << "testing move " << move.toString() << "\n";
    if (legal_move(move)) {
      // cerr << "PASSED TEST! " << move.toString() << "\n";
      if (move.is_pawn_promotion()) {
	moves.add(move); // Promotion to queen
	--move.special_move;
	moves.add(move); // Promotion to rook
	--move.special_move;
	moves.add(move); // Promotion to bishop
	--move.special_move;
	moves.add(move); // Promotion to knight
      } else {
	moves.add(move);
      }
    }
  }
}

template <class CONTAINER>
void Board2plus::get_move_list(CONTAINER &moves, MoveSet &move_set) {
  //moves.clear();
  move_list.init_iterator(player);
  while (move_list.iterate()) {
    Move move = move_list.deref_iterator();
    // cerr << "testing move " << move.toString() << "\n";
    if (legal_move(move)) {
      // cerr << "PASSED TEST! " << move.toString() << "\n";
      if (move.is_pawn_promotion()) {
	if (!move_set.find(move)) moves.add(move); // Promotion to queen
	--move.special_move;
	if (!move_set.find(move)) moves.add(move); // Promotion to rook
	--move.special_move;
	if (!move_set.find(move)) moves.add(move); // Promotion to bishop
	--move.special_move;
	if (!move_set.find(move)) moves.add(move); // Promotion to knight
      } else {
	if (!move_set.find(move)) moves.add(move);
      }
    }
  }
}


#endif
